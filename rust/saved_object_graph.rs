// This file is generated by rust-protobuf 2.10.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/core/protobuf/saved_object_graph.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_10_1;

#[derive(PartialEq,Clone,Default)]
pub struct SavedObjectGraph {
    // message fields
    pub nodes: ::protobuf::RepeatedField<SavedObject>,
    pub concrete_functions: ::std::collections::HashMap<::std::string::String, SavedConcreteFunction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedObjectGraph {
    fn default() -> &'a SavedObjectGraph {
        <SavedObjectGraph as ::protobuf::Message>::default_instance()
    }
}

impl SavedObjectGraph {
    pub fn new() -> SavedObjectGraph {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.SavedObject nodes = 1;


    pub fn get_nodes(&self) -> &[SavedObject] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<SavedObject>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<SavedObject> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<SavedObject> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // repeated .tensorflow.SavedObjectGraph.ConcreteFunctionsEntry concrete_functions = 2;


    pub fn get_concrete_functions(&self) -> &::std::collections::HashMap<::std::string::String, SavedConcreteFunction> {
        &self.concrete_functions
    }
    pub fn clear_concrete_functions(&mut self) {
        self.concrete_functions.clear();
    }

    // Param is passed by value, moved
    pub fn set_concrete_functions(&mut self, v: ::std::collections::HashMap<::std::string::String, SavedConcreteFunction>) {
        self.concrete_functions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concrete_functions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, SavedConcreteFunction> {
        &mut self.concrete_functions
    }

    // Take field
    pub fn take_concrete_functions(&mut self) -> ::std::collections::HashMap<::std::string::String, SavedConcreteFunction> {
        ::std::mem::replace(&mut self.concrete_functions, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for SavedObjectGraph {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SavedConcreteFunction>>(wire_type, is, &mut self.concrete_functions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SavedConcreteFunction>>(2, &self.concrete_functions);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SavedConcreteFunction>>(2, &self.concrete_functions, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedObjectGraph {
        SavedObjectGraph::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SavedObject>>(
                    "nodes",
                    |m: &SavedObjectGraph| { &m.nodes },
                    |m: &mut SavedObjectGraph| { &mut m.nodes },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SavedConcreteFunction>>(
                    "concrete_functions",
                    |m: &SavedObjectGraph| { &m.concrete_functions },
                    |m: &mut SavedObjectGraph| { &mut m.concrete_functions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SavedObjectGraph>(
                    "SavedObjectGraph",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SavedObjectGraph {
        static mut instance: ::protobuf::lazy::Lazy<SavedObjectGraph> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SavedObjectGraph,
        };
        unsafe {
            instance.get(SavedObjectGraph::new)
        }
    }
}

impl ::protobuf::Clear for SavedObjectGraph {
    fn clear(&mut self) {
        self.nodes.clear();
        self.concrete_functions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedObjectGraph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedObjectGraph {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedObject {
    // message fields
    pub children: ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_ObjectReference>,
    pub slot_variables: ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_SlotVariableReference>,
    // message oneof groups
    pub kind: ::std::option::Option<SavedObject_oneof_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedObject {
    fn default() -> &'a SavedObject {
        <SavedObject as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum SavedObject_oneof_kind {
    user_object(SavedUserObject),
    asset(SavedAsset),
    function(SavedFunction),
    variable(SavedVariable),
    bare_concrete_function(SavedBareConcreteFunction),
    constant(SavedConstant),
    resource(SavedResource),
}

impl SavedObject {
    pub fn new() -> SavedObject {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.TrackableObjectGraph.TrackableObject.ObjectReference children = 1;


    pub fn get_children(&self) -> &[super::trackable_object_graph::TrackableObjectGraph_TrackableObject_ObjectReference] {
        &self.children
    }
    pub fn clear_children(&mut self) {
        self.children.clear();
    }

    // Param is passed by value, moved
    pub fn set_children(&mut self, v: ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_ObjectReference>) {
        self.children = v;
    }

    // Mutable pointer to the field.
    pub fn mut_children(&mut self) -> &mut ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_ObjectReference> {
        &mut self.children
    }

    // Take field
    pub fn take_children(&mut self) -> ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_ObjectReference> {
        ::std::mem::replace(&mut self.children, ::protobuf::RepeatedField::new())
    }

    // repeated .tensorflow.TrackableObjectGraph.TrackableObject.SlotVariableReference slot_variables = 3;


    pub fn get_slot_variables(&self) -> &[super::trackable_object_graph::TrackableObjectGraph_TrackableObject_SlotVariableReference] {
        &self.slot_variables
    }
    pub fn clear_slot_variables(&mut self) {
        self.slot_variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_slot_variables(&mut self, v: ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_SlotVariableReference>) {
        self.slot_variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_slot_variables(&mut self) -> &mut ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_SlotVariableReference> {
        &mut self.slot_variables
    }

    // Take field
    pub fn take_slot_variables(&mut self) -> ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_SlotVariableReference> {
        ::std::mem::replace(&mut self.slot_variables, ::protobuf::RepeatedField::new())
    }

    // .tensorflow.SavedUserObject user_object = 4;


    pub fn get_user_object(&self) -> &SavedUserObject {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::user_object(ref v)) => v,
            _ => SavedUserObject::default_instance(),
        }
    }
    pub fn clear_user_object(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_user_object(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::user_object(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_object(&mut self, v: SavedUserObject) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::user_object(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_object(&mut self) -> &mut SavedUserObject {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::user_object(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::user_object(SavedUserObject::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::user_object(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_object(&mut self) -> SavedUserObject {
        if self.has_user_object() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::user_object(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedUserObject::new()
        }
    }

    // .tensorflow.SavedAsset asset = 5;


    pub fn get_asset(&self) -> &SavedAsset {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::asset(ref v)) => v,
            _ => SavedAsset::default_instance(),
        }
    }
    pub fn clear_asset(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_asset(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::asset(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_asset(&mut self, v: SavedAsset) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::asset(v))
    }

    // Mutable pointer to the field.
    pub fn mut_asset(&mut self) -> &mut SavedAsset {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::asset(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::asset(SavedAsset::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::asset(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_asset(&mut self) -> SavedAsset {
        if self.has_asset() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::asset(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedAsset::new()
        }
    }

    // .tensorflow.SavedFunction function = 6;


    pub fn get_function(&self) -> &SavedFunction {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::function(ref v)) => v,
            _ => SavedFunction::default_instance(),
        }
    }
    pub fn clear_function(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_function(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::function(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_function(&mut self, v: SavedFunction) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::function(v))
    }

    // Mutable pointer to the field.
    pub fn mut_function(&mut self) -> &mut SavedFunction {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::function(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::function(SavedFunction::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::function(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_function(&mut self) -> SavedFunction {
        if self.has_function() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::function(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedFunction::new()
        }
    }

    // .tensorflow.SavedVariable variable = 7;


    pub fn get_variable(&self) -> &SavedVariable {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::variable(ref v)) => v,
            _ => SavedVariable::default_instance(),
        }
    }
    pub fn clear_variable(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_variable(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::variable(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_variable(&mut self, v: SavedVariable) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::variable(v))
    }

    // Mutable pointer to the field.
    pub fn mut_variable(&mut self) -> &mut SavedVariable {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::variable(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::variable(SavedVariable::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::variable(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_variable(&mut self) -> SavedVariable {
        if self.has_variable() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::variable(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedVariable::new()
        }
    }

    // .tensorflow.SavedBareConcreteFunction bare_concrete_function = 8;


    pub fn get_bare_concrete_function(&self) -> &SavedBareConcreteFunction {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(ref v)) => v,
            _ => SavedBareConcreteFunction::default_instance(),
        }
    }
    pub fn clear_bare_concrete_function(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_bare_concrete_function(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bare_concrete_function(&mut self, v: SavedBareConcreteFunction) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bare_concrete_function(&mut self) -> &mut SavedBareConcreteFunction {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(SavedBareConcreteFunction::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bare_concrete_function(&mut self) -> SavedBareConcreteFunction {
        if self.has_bare_concrete_function() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedBareConcreteFunction::new()
        }
    }

    // .tensorflow.SavedConstant constant = 9;


    pub fn get_constant(&self) -> &SavedConstant {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::constant(ref v)) => v,
            _ => SavedConstant::default_instance(),
        }
    }
    pub fn clear_constant(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_constant(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::constant(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_constant(&mut self, v: SavedConstant) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::constant(v))
    }

    // Mutable pointer to the field.
    pub fn mut_constant(&mut self) -> &mut SavedConstant {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::constant(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::constant(SavedConstant::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::constant(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_constant(&mut self) -> SavedConstant {
        if self.has_constant() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::constant(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedConstant::new()
        }
    }

    // .tensorflow.SavedResource resource = 10;


    pub fn get_resource(&self) -> &SavedResource {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::resource(ref v)) => v,
            _ => SavedResource::default_instance(),
        }
    }
    pub fn clear_resource(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_resource(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::resource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: SavedResource) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::resource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resource(&mut self) -> &mut SavedResource {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::resource(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::resource(SavedResource::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::resource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resource(&mut self) -> SavedResource {
        if self.has_resource() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::resource(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedResource::new()
        }
    }
}

impl ::protobuf::Message for SavedObject {
    fn is_initialized(&self) -> bool {
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.slot_variables {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(SavedObject_oneof_kind::user_object(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::asset(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::function(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::variable(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::bare_concrete_function(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::constant(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::resource(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.children)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.slot_variables)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::user_object(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::asset(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::function(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::variable(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::constant(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::resource(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.slot_variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &SavedObject_oneof_kind::user_object(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::asset(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::function(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::variable(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::bare_concrete_function(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::constant(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::resource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.children {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.slot_variables {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &SavedObject_oneof_kind::user_object(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::asset(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::function(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::variable(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::bare_concrete_function(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::constant(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::resource(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedObject {
        SavedObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_ObjectReference>>(
                    "children",
                    |m: &SavedObject| { &m.children },
                    |m: &mut SavedObject| { &mut m.children },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_SlotVariableReference>>(
                    "slot_variables",
                    |m: &SavedObject| { &m.slot_variables },
                    |m: &mut SavedObject| { &mut m.slot_variables },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedUserObject>(
                    "user_object",
                    SavedObject::has_user_object,
                    SavedObject::get_user_object,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedAsset>(
                    "asset",
                    SavedObject::has_asset,
                    SavedObject::get_asset,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedFunction>(
                    "function",
                    SavedObject::has_function,
                    SavedObject::get_function,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedVariable>(
                    "variable",
                    SavedObject::has_variable,
                    SavedObject::get_variable,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedBareConcreteFunction>(
                    "bare_concrete_function",
                    SavedObject::has_bare_concrete_function,
                    SavedObject::get_bare_concrete_function,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedConstant>(
                    "constant",
                    SavedObject::has_constant,
                    SavedObject::get_constant,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedResource>(
                    "resource",
                    SavedObject::has_resource,
                    SavedObject::get_resource,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SavedObject>(
                    "SavedObject",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SavedObject {
        static mut instance: ::protobuf::lazy::Lazy<SavedObject> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SavedObject,
        };
        unsafe {
            instance.get(SavedObject::new)
        }
    }
}

impl ::protobuf::Clear for SavedObject {
    fn clear(&mut self) {
        self.children.clear();
        self.slot_variables.clear();
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedObject {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedUserObject {
    // message fields
    pub identifier: ::std::string::String,
    pub version: ::protobuf::SingularPtrField<super::versions::VersionDef>,
    pub metadata: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedUserObject {
    fn default() -> &'a SavedUserObject {
        <SavedUserObject as ::protobuf::Message>::default_instance()
    }
}

impl SavedUserObject {
    pub fn new() -> SavedUserObject {
        ::std::default::Default::default()
    }

    // string identifier = 1;


    pub fn get_identifier(&self) -> &str {
        &self.identifier
    }
    pub fn clear_identifier(&mut self) {
        self.identifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        &mut self.identifier
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identifier, ::std::string::String::new())
    }

    // .tensorflow.VersionDef version = 2;


    pub fn get_version(&self) -> &super::versions::VersionDef {
        self.version.as_ref().unwrap_or_else(|| super::versions::VersionDef::default_instance())
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: super::versions::VersionDef) {
        self.version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut super::versions::VersionDef {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> super::versions::VersionDef {
        self.version.take().unwrap_or_else(|| super::versions::VersionDef::new())
    }

    // string metadata = 3;


    pub fn get_metadata(&self) -> &str {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metadata, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SavedUserObject {
    fn is_initialized(&self) -> bool {
        for v in &self.version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identifier)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identifier);
        }
        if let Some(ref v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identifier.is_empty() {
            os.write_string(1, &self.identifier)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.metadata.is_empty() {
            os.write_string(3, &self.metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedUserObject {
        SavedUserObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identifier",
                    |m: &SavedUserObject| { &m.identifier },
                    |m: &mut SavedUserObject| { &mut m.identifier },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::versions::VersionDef>>(
                    "version",
                    |m: &SavedUserObject| { &m.version },
                    |m: &mut SavedUserObject| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &SavedUserObject| { &m.metadata },
                    |m: &mut SavedUserObject| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SavedUserObject>(
                    "SavedUserObject",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SavedUserObject {
        static mut instance: ::protobuf::lazy::Lazy<SavedUserObject> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SavedUserObject,
        };
        unsafe {
            instance.get(SavedUserObject::new)
        }
    }
}

impl ::protobuf::Clear for SavedUserObject {
    fn clear(&mut self) {
        self.identifier.clear();
        self.version.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedUserObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedUserObject {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedAsset {
    // message fields
    pub asset_file_def_index: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedAsset {
    fn default() -> &'a SavedAsset {
        <SavedAsset as ::protobuf::Message>::default_instance()
    }
}

impl SavedAsset {
    pub fn new() -> SavedAsset {
        ::std::default::Default::default()
    }

    // int32 asset_file_def_index = 1;


    pub fn get_asset_file_def_index(&self) -> i32 {
        self.asset_file_def_index
    }
    pub fn clear_asset_file_def_index(&mut self) {
        self.asset_file_def_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_asset_file_def_index(&mut self, v: i32) {
        self.asset_file_def_index = v;
    }
}

impl ::protobuf::Message for SavedAsset {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.asset_file_def_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.asset_file_def_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.asset_file_def_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.asset_file_def_index != 0 {
            os.write_int32(1, self.asset_file_def_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedAsset {
        SavedAsset::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "asset_file_def_index",
                    |m: &SavedAsset| { &m.asset_file_def_index },
                    |m: &mut SavedAsset| { &mut m.asset_file_def_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SavedAsset>(
                    "SavedAsset",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SavedAsset {
        static mut instance: ::protobuf::lazy::Lazy<SavedAsset> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SavedAsset,
        };
        unsafe {
            instance.get(SavedAsset::new)
        }
    }
}

impl ::protobuf::Clear for SavedAsset {
    fn clear(&mut self) {
        self.asset_file_def_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedAsset {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedFunction {
    // message fields
    pub concrete_functions: ::protobuf::RepeatedField<::std::string::String>,
    pub function_spec: ::protobuf::SingularPtrField<FunctionSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedFunction {
    fn default() -> &'a SavedFunction {
        <SavedFunction as ::protobuf::Message>::default_instance()
    }
}

impl SavedFunction {
    pub fn new() -> SavedFunction {
        ::std::default::Default::default()
    }

    // repeated string concrete_functions = 1;


    pub fn get_concrete_functions(&self) -> &[::std::string::String] {
        &self.concrete_functions
    }
    pub fn clear_concrete_functions(&mut self) {
        self.concrete_functions.clear();
    }

    // Param is passed by value, moved
    pub fn set_concrete_functions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.concrete_functions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concrete_functions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.concrete_functions
    }

    // Take field
    pub fn take_concrete_functions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.concrete_functions, ::protobuf::RepeatedField::new())
    }

    // .tensorflow.FunctionSpec function_spec = 2;


    pub fn get_function_spec(&self) -> &FunctionSpec {
        self.function_spec.as_ref().unwrap_or_else(|| FunctionSpec::default_instance())
    }
    pub fn clear_function_spec(&mut self) {
        self.function_spec.clear();
    }

    pub fn has_function_spec(&self) -> bool {
        self.function_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_spec(&mut self, v: FunctionSpec) {
        self.function_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_spec(&mut self) -> &mut FunctionSpec {
        if self.function_spec.is_none() {
            self.function_spec.set_default();
        }
        self.function_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_function_spec(&mut self) -> FunctionSpec {
        self.function_spec.take().unwrap_or_else(|| FunctionSpec::new())
    }
}

impl ::protobuf::Message for SavedFunction {
    fn is_initialized(&self) -> bool {
        for v in &self.function_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.concrete_functions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.function_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.concrete_functions {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.function_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.concrete_functions {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.function_spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedFunction {
        SavedFunction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "concrete_functions",
                    |m: &SavedFunction| { &m.concrete_functions },
                    |m: &mut SavedFunction| { &mut m.concrete_functions },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FunctionSpec>>(
                    "function_spec",
                    |m: &SavedFunction| { &m.function_spec },
                    |m: &mut SavedFunction| { &mut m.function_spec },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SavedFunction>(
                    "SavedFunction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SavedFunction {
        static mut instance: ::protobuf::lazy::Lazy<SavedFunction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SavedFunction,
        };
        unsafe {
            instance.get(SavedFunction::new)
        }
    }
}

impl ::protobuf::Clear for SavedFunction {
    fn clear(&mut self) {
        self.concrete_functions.clear();
        self.function_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedFunction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedConcreteFunction {
    // message fields
    pub bound_inputs: ::std::vec::Vec<i32>,
    pub canonicalized_input_signature: ::protobuf::SingularPtrField<super::struct_pb::StructuredValue>,
    pub output_signature: ::protobuf::SingularPtrField<super::struct_pb::StructuredValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedConcreteFunction {
    fn default() -> &'a SavedConcreteFunction {
        <SavedConcreteFunction as ::protobuf::Message>::default_instance()
    }
}

impl SavedConcreteFunction {
    pub fn new() -> SavedConcreteFunction {
        ::std::default::Default::default()
    }

    // repeated int32 bound_inputs = 2;


    pub fn get_bound_inputs(&self) -> &[i32] {
        &self.bound_inputs
    }
    pub fn clear_bound_inputs(&mut self) {
        self.bound_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_bound_inputs(&mut self, v: ::std::vec::Vec<i32>) {
        self.bound_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bound_inputs(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.bound_inputs
    }

    // Take field
    pub fn take_bound_inputs(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.bound_inputs, ::std::vec::Vec::new())
    }

    // .tensorflow.StructuredValue canonicalized_input_signature = 3;


    pub fn get_canonicalized_input_signature(&self) -> &super::struct_pb::StructuredValue {
        self.canonicalized_input_signature.as_ref().unwrap_or_else(|| super::struct_pb::StructuredValue::default_instance())
    }
    pub fn clear_canonicalized_input_signature(&mut self) {
        self.canonicalized_input_signature.clear();
    }

    pub fn has_canonicalized_input_signature(&self) -> bool {
        self.canonicalized_input_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_canonicalized_input_signature(&mut self, v: super::struct_pb::StructuredValue) {
        self.canonicalized_input_signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_canonicalized_input_signature(&mut self) -> &mut super::struct_pb::StructuredValue {
        if self.canonicalized_input_signature.is_none() {
            self.canonicalized_input_signature.set_default();
        }
        self.canonicalized_input_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_canonicalized_input_signature(&mut self) -> super::struct_pb::StructuredValue {
        self.canonicalized_input_signature.take().unwrap_or_else(|| super::struct_pb::StructuredValue::new())
    }

    // .tensorflow.StructuredValue output_signature = 4;


    pub fn get_output_signature(&self) -> &super::struct_pb::StructuredValue {
        self.output_signature.as_ref().unwrap_or_else(|| super::struct_pb::StructuredValue::default_instance())
    }
    pub fn clear_output_signature(&mut self) {
        self.output_signature.clear();
    }

    pub fn has_output_signature(&self) -> bool {
        self.output_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_signature(&mut self, v: super::struct_pb::StructuredValue) {
        self.output_signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_signature(&mut self) -> &mut super::struct_pb::StructuredValue {
        if self.output_signature.is_none() {
            self.output_signature.set_default();
        }
        self.output_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_signature(&mut self) -> super::struct_pb::StructuredValue {
        self.output_signature.take().unwrap_or_else(|| super::struct_pb::StructuredValue::new())
    }
}

impl ::protobuf::Message for SavedConcreteFunction {
    fn is_initialized(&self) -> bool {
        for v in &self.canonicalized_input_signature {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_signature {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.bound_inputs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.canonicalized_input_signature)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bound_inputs {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.canonicalized_input_signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output_signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bound_inputs {
            os.write_int32(2, *v)?;
        };
        if let Some(ref v) = self.canonicalized_input_signature.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output_signature.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedConcreteFunction {
        SavedConcreteFunction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "bound_inputs",
                    |m: &SavedConcreteFunction| { &m.bound_inputs },
                    |m: &mut SavedConcreteFunction| { &mut m.bound_inputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::struct_pb::StructuredValue>>(
                    "canonicalized_input_signature",
                    |m: &SavedConcreteFunction| { &m.canonicalized_input_signature },
                    |m: &mut SavedConcreteFunction| { &mut m.canonicalized_input_signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::struct_pb::StructuredValue>>(
                    "output_signature",
                    |m: &SavedConcreteFunction| { &m.output_signature },
                    |m: &mut SavedConcreteFunction| { &mut m.output_signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SavedConcreteFunction>(
                    "SavedConcreteFunction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SavedConcreteFunction {
        static mut instance: ::protobuf::lazy::Lazy<SavedConcreteFunction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SavedConcreteFunction,
        };
        unsafe {
            instance.get(SavedConcreteFunction::new)
        }
    }
}

impl ::protobuf::Clear for SavedConcreteFunction {
    fn clear(&mut self) {
        self.bound_inputs.clear();
        self.canonicalized_input_signature.clear();
        self.output_signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedConcreteFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedConcreteFunction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedBareConcreteFunction {
    // message fields
    pub concrete_function_name: ::std::string::String,
    pub argument_keywords: ::protobuf::RepeatedField<::std::string::String>,
    pub allowed_positional_arguments: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedBareConcreteFunction {
    fn default() -> &'a SavedBareConcreteFunction {
        <SavedBareConcreteFunction as ::protobuf::Message>::default_instance()
    }
}

impl SavedBareConcreteFunction {
    pub fn new() -> SavedBareConcreteFunction {
        ::std::default::Default::default()
    }

    // string concrete_function_name = 1;


    pub fn get_concrete_function_name(&self) -> &str {
        &self.concrete_function_name
    }
    pub fn clear_concrete_function_name(&mut self) {
        self.concrete_function_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_concrete_function_name(&mut self, v: ::std::string::String) {
        self.concrete_function_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concrete_function_name(&mut self) -> &mut ::std::string::String {
        &mut self.concrete_function_name
    }

    // Take field
    pub fn take_concrete_function_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concrete_function_name, ::std::string::String::new())
    }

    // repeated string argument_keywords = 2;


    pub fn get_argument_keywords(&self) -> &[::std::string::String] {
        &self.argument_keywords
    }
    pub fn clear_argument_keywords(&mut self) {
        self.argument_keywords.clear();
    }

    // Param is passed by value, moved
    pub fn set_argument_keywords(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.argument_keywords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_argument_keywords(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.argument_keywords
    }

    // Take field
    pub fn take_argument_keywords(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.argument_keywords, ::protobuf::RepeatedField::new())
    }

    // int64 allowed_positional_arguments = 3;


    pub fn get_allowed_positional_arguments(&self) -> i64 {
        self.allowed_positional_arguments
    }
    pub fn clear_allowed_positional_arguments(&mut self) {
        self.allowed_positional_arguments = 0;
    }

    // Param is passed by value, moved
    pub fn set_allowed_positional_arguments(&mut self, v: i64) {
        self.allowed_positional_arguments = v;
    }
}

impl ::protobuf::Message for SavedBareConcreteFunction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concrete_function_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.argument_keywords)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.allowed_positional_arguments = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.concrete_function_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.concrete_function_name);
        }
        for value in &self.argument_keywords {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.allowed_positional_arguments != 0 {
            my_size += ::protobuf::rt::value_size(3, self.allowed_positional_arguments, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.concrete_function_name.is_empty() {
            os.write_string(1, &self.concrete_function_name)?;
        }
        for v in &self.argument_keywords {
            os.write_string(2, &v)?;
        };
        if self.allowed_positional_arguments != 0 {
            os.write_int64(3, self.allowed_positional_arguments)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedBareConcreteFunction {
        SavedBareConcreteFunction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "concrete_function_name",
                    |m: &SavedBareConcreteFunction| { &m.concrete_function_name },
                    |m: &mut SavedBareConcreteFunction| { &mut m.concrete_function_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "argument_keywords",
                    |m: &SavedBareConcreteFunction| { &m.argument_keywords },
                    |m: &mut SavedBareConcreteFunction| { &mut m.argument_keywords },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "allowed_positional_arguments",
                    |m: &SavedBareConcreteFunction| { &m.allowed_positional_arguments },
                    |m: &mut SavedBareConcreteFunction| { &mut m.allowed_positional_arguments },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SavedBareConcreteFunction>(
                    "SavedBareConcreteFunction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SavedBareConcreteFunction {
        static mut instance: ::protobuf::lazy::Lazy<SavedBareConcreteFunction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SavedBareConcreteFunction,
        };
        unsafe {
            instance.get(SavedBareConcreteFunction::new)
        }
    }
}

impl ::protobuf::Clear for SavedBareConcreteFunction {
    fn clear(&mut self) {
        self.concrete_function_name.clear();
        self.argument_keywords.clear();
        self.allowed_positional_arguments = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedBareConcreteFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedBareConcreteFunction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedConstant {
    // message fields
    pub operation: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedConstant {
    fn default() -> &'a SavedConstant {
        <SavedConstant as ::protobuf::Message>::default_instance()
    }
}

impl SavedConstant {
    pub fn new() -> SavedConstant {
        ::std::default::Default::default()
    }

    // string operation = 1;


    pub fn get_operation(&self) -> &str {
        &self.operation
    }
    pub fn clear_operation(&mut self) {
        self.operation.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ::std::string::String) {
        self.operation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation(&mut self) -> &mut ::std::string::String {
        &mut self.operation
    }

    // Take field
    pub fn take_operation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SavedConstant {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.operation.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.operation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.operation.is_empty() {
            os.write_string(1, &self.operation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedConstant {
        SavedConstant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "operation",
                    |m: &SavedConstant| { &m.operation },
                    |m: &mut SavedConstant| { &mut m.operation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SavedConstant>(
                    "SavedConstant",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SavedConstant {
        static mut instance: ::protobuf::lazy::Lazy<SavedConstant> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SavedConstant,
        };
        unsafe {
            instance.get(SavedConstant::new)
        }
    }
}

impl ::protobuf::Clear for SavedConstant {
    fn clear(&mut self) {
        self.operation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedConstant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedConstant {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedVariable {
    // message fields
    pub dtype: super::types::DataType,
    pub shape: ::protobuf::SingularPtrField<super::tensor_shape::TensorShapeProto>,
    pub trainable: bool,
    pub synchronization: super::variable::VariableSynchronization,
    pub aggregation: super::variable::VariableAggregation,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedVariable {
    fn default() -> &'a SavedVariable {
        <SavedVariable as ::protobuf::Message>::default_instance()
    }
}

impl SavedVariable {
    pub fn new() -> SavedVariable {
        ::std::default::Default::default()
    }

    // .tensorflow.DataType dtype = 1;


    pub fn get_dtype(&self) -> super::types::DataType {
        self.dtype
    }
    pub fn clear_dtype(&mut self) {
        self.dtype = super::types::DataType::DT_INVALID;
    }

    // Param is passed by value, moved
    pub fn set_dtype(&mut self, v: super::types::DataType) {
        self.dtype = v;
    }

    // .tensorflow.TensorShapeProto shape = 2;


    pub fn get_shape(&self) -> &super::tensor_shape::TensorShapeProto {
        self.shape.as_ref().unwrap_or_else(|| super::tensor_shape::TensorShapeProto::default_instance())
    }
    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: super::tensor_shape::TensorShapeProto) {
        self.shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape(&mut self) -> &mut super::tensor_shape::TensorShapeProto {
        if self.shape.is_none() {
            self.shape.set_default();
        }
        self.shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape(&mut self) -> super::tensor_shape::TensorShapeProto {
        self.shape.take().unwrap_or_else(|| super::tensor_shape::TensorShapeProto::new())
    }

    // bool trainable = 3;


    pub fn get_trainable(&self) -> bool {
        self.trainable
    }
    pub fn clear_trainable(&mut self) {
        self.trainable = false;
    }

    // Param is passed by value, moved
    pub fn set_trainable(&mut self, v: bool) {
        self.trainable = v;
    }

    // .tensorflow.VariableSynchronization synchronization = 4;


    pub fn get_synchronization(&self) -> super::variable::VariableSynchronization {
        self.synchronization
    }
    pub fn clear_synchronization(&mut self) {
        self.synchronization = super::variable::VariableSynchronization::VARIABLE_SYNCHRONIZATION_AUTO;
    }

    // Param is passed by value, moved
    pub fn set_synchronization(&mut self, v: super::variable::VariableSynchronization) {
        self.synchronization = v;
    }

    // .tensorflow.VariableAggregation aggregation = 5;


    pub fn get_aggregation(&self) -> super::variable::VariableAggregation {
        self.aggregation
    }
    pub fn clear_aggregation(&mut self) {
        self.aggregation = super::variable::VariableAggregation::VARIABLE_AGGREGATION_NONE;
    }

    // Param is passed by value, moved
    pub fn set_aggregation(&mut self, v: super::variable::VariableAggregation) {
        self.aggregation = v;
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SavedVariable {
    fn is_initialized(&self) -> bool {
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dtype, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trainable = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.synchronization, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.aggregation, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dtype != super::types::DataType::DT_INVALID {
            my_size += ::protobuf::rt::enum_size(1, self.dtype);
        }
        if let Some(ref v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.trainable != false {
            my_size += 2;
        }
        if self.synchronization != super::variable::VariableSynchronization::VARIABLE_SYNCHRONIZATION_AUTO {
            my_size += ::protobuf::rt::enum_size(4, self.synchronization);
        }
        if self.aggregation != super::variable::VariableAggregation::VARIABLE_AGGREGATION_NONE {
            my_size += ::protobuf::rt::enum_size(5, self.aggregation);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dtype != super::types::DataType::DT_INVALID {
            os.write_enum(1, self.dtype.value())?;
        }
        if let Some(ref v) = self.shape.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.trainable != false {
            os.write_bool(3, self.trainable)?;
        }
        if self.synchronization != super::variable::VariableSynchronization::VARIABLE_SYNCHRONIZATION_AUTO {
            os.write_enum(4, self.synchronization.value())?;
        }
        if self.aggregation != super::variable::VariableAggregation::VARIABLE_AGGREGATION_NONE {
            os.write_enum(5, self.aggregation.value())?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedVariable {
        SavedVariable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::types::DataType>>(
                    "dtype",
                    |m: &SavedVariable| { &m.dtype },
                    |m: &mut SavedVariable| { &mut m.dtype },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tensor_shape::TensorShapeProto>>(
                    "shape",
                    |m: &SavedVariable| { &m.shape },
                    |m: &mut SavedVariable| { &mut m.shape },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "trainable",
                    |m: &SavedVariable| { &m.trainable },
                    |m: &mut SavedVariable| { &mut m.trainable },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::variable::VariableSynchronization>>(
                    "synchronization",
                    |m: &SavedVariable| { &m.synchronization },
                    |m: &mut SavedVariable| { &mut m.synchronization },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::variable::VariableAggregation>>(
                    "aggregation",
                    |m: &SavedVariable| { &m.aggregation },
                    |m: &mut SavedVariable| { &mut m.aggregation },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &SavedVariable| { &m.name },
                    |m: &mut SavedVariable| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SavedVariable>(
                    "SavedVariable",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SavedVariable {
        static mut instance: ::protobuf::lazy::Lazy<SavedVariable> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SavedVariable,
        };
        unsafe {
            instance.get(SavedVariable::new)
        }
    }
}

impl ::protobuf::Clear for SavedVariable {
    fn clear(&mut self) {
        self.dtype = super::types::DataType::DT_INVALID;
        self.shape.clear();
        self.trainable = false;
        self.synchronization = super::variable::VariableSynchronization::VARIABLE_SYNCHRONIZATION_AUTO;
        self.aggregation = super::variable::VariableAggregation::VARIABLE_AGGREGATION_NONE;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedVariable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedVariable {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FunctionSpec {
    // message fields
    pub fullargspec: ::protobuf::SingularPtrField<super::struct_pb::StructuredValue>,
    pub is_method: bool,
    pub input_signature: ::protobuf::SingularPtrField<super::struct_pb::StructuredValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FunctionSpec {
    fn default() -> &'a FunctionSpec {
        <FunctionSpec as ::protobuf::Message>::default_instance()
    }
}

impl FunctionSpec {
    pub fn new() -> FunctionSpec {
        ::std::default::Default::default()
    }

    // .tensorflow.StructuredValue fullargspec = 1;


    pub fn get_fullargspec(&self) -> &super::struct_pb::StructuredValue {
        self.fullargspec.as_ref().unwrap_or_else(|| super::struct_pb::StructuredValue::default_instance())
    }
    pub fn clear_fullargspec(&mut self) {
        self.fullargspec.clear();
    }

    pub fn has_fullargspec(&self) -> bool {
        self.fullargspec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullargspec(&mut self, v: super::struct_pb::StructuredValue) {
        self.fullargspec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullargspec(&mut self) -> &mut super::struct_pb::StructuredValue {
        if self.fullargspec.is_none() {
            self.fullargspec.set_default();
        }
        self.fullargspec.as_mut().unwrap()
    }

    // Take field
    pub fn take_fullargspec(&mut self) -> super::struct_pb::StructuredValue {
        self.fullargspec.take().unwrap_or_else(|| super::struct_pb::StructuredValue::new())
    }

    // bool is_method = 2;


    pub fn get_is_method(&self) -> bool {
        self.is_method
    }
    pub fn clear_is_method(&mut self) {
        self.is_method = false;
    }

    // Param is passed by value, moved
    pub fn set_is_method(&mut self, v: bool) {
        self.is_method = v;
    }

    // .tensorflow.StructuredValue input_signature = 5;


    pub fn get_input_signature(&self) -> &super::struct_pb::StructuredValue {
        self.input_signature.as_ref().unwrap_or_else(|| super::struct_pb::StructuredValue::default_instance())
    }
    pub fn clear_input_signature(&mut self) {
        self.input_signature.clear();
    }

    pub fn has_input_signature(&self) -> bool {
        self.input_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_signature(&mut self, v: super::struct_pb::StructuredValue) {
        self.input_signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_signature(&mut self) -> &mut super::struct_pb::StructuredValue {
        if self.input_signature.is_none() {
            self.input_signature.set_default();
        }
        self.input_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_signature(&mut self) -> super::struct_pb::StructuredValue {
        self.input_signature.take().unwrap_or_else(|| super::struct_pb::StructuredValue::new())
    }
}

impl ::protobuf::Message for FunctionSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.fullargspec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input_signature {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fullargspec)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_method = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input_signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fullargspec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_method != false {
            my_size += 2;
        }
        if let Some(ref v) = self.input_signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fullargspec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_method != false {
            os.write_bool(2, self.is_method)?;
        }
        if let Some(ref v) = self.input_signature.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FunctionSpec {
        FunctionSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::struct_pb::StructuredValue>>(
                    "fullargspec",
                    |m: &FunctionSpec| { &m.fullargspec },
                    |m: &mut FunctionSpec| { &mut m.fullargspec },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_method",
                    |m: &FunctionSpec| { &m.is_method },
                    |m: &mut FunctionSpec| { &mut m.is_method },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::struct_pb::StructuredValue>>(
                    "input_signature",
                    |m: &FunctionSpec| { &m.input_signature },
                    |m: &mut FunctionSpec| { &mut m.input_signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FunctionSpec>(
                    "FunctionSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FunctionSpec {
        static mut instance: ::protobuf::lazy::Lazy<FunctionSpec> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FunctionSpec,
        };
        unsafe {
            instance.get(FunctionSpec::new)
        }
    }
}

impl ::protobuf::Clear for FunctionSpec {
    fn clear(&mut self) {
        self.fullargspec.clear();
        self.is_method = false;
        self.input_signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FunctionSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FunctionSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedResource {
    // message fields
    pub device: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedResource {
    fn default() -> &'a SavedResource {
        <SavedResource as ::protobuf::Message>::default_instance()
    }
}

impl SavedResource {
    pub fn new() -> SavedResource {
        ::std::default::Default::default()
    }

    // string device = 1;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SavedResource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.device.is_empty() {
            os.write_string(1, &self.device)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedResource {
        SavedResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device",
                    |m: &SavedResource| { &m.device },
                    |m: &mut SavedResource| { &mut m.device },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SavedResource>(
                    "SavedResource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SavedResource {
        static mut instance: ::protobuf::lazy::Lazy<SavedResource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SavedResource,
        };
        unsafe {
            instance.get(SavedResource::new)
        }
    }
}

impl ::protobuf::Clear for SavedResource {
    fn clear(&mut self) {
        self.device.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedResource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n1tensorflow/core/protobuf/saved_object_graph.proto\x12\ntensorflow\x1a\
    5tensorflow/core/protobuf/trackable_object_graph.proto\x1a%tensorflow/co\
    re/protobuf/struct.proto\x1a,tensorflow/core/framework/tensor_shape.prot\
    o\x1a%tensorflow/core/framework/types.proto\x1a(tensorflow/core/framewor\
    k/versions.proto\x1a(tensorflow/core/framework/variable.proto\"\x8e\x02\
    \n\x10SavedObjectGraph\x12-\n\x05nodes\x18\x01\x20\x03(\x0b2\x17.tensorf\
    low.SavedObjectR\x05nodes\x12b\n\x12concrete_functions\x18\x02\x20\x03(\
    \x0b23.tensorflow.SavedObjectGraph.ConcreteFunctionsEntryR\x11concreteFu\
    nctions\x1ag\n\x16ConcreteFunctionsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x127\n\x05value\x18\x02\x20\x01(\x0b2!.tensorflow.SavedC\
    oncreteFunctionR\x05value:\x028\x01\"\xa7\x05\n\x0bSavedObject\x12\\\n\
    \x08children\x18\x01\x20\x03(\x0b2@.tensorflow.TrackableObjectGraph.Trac\
    kableObject.ObjectReferenceR\x08children\x12m\n\x0eslot_variables\x18\
    \x03\x20\x03(\x0b2F.tensorflow.TrackableObjectGraph.TrackableObject.Slot\
    VariableReferenceR\rslotVariables\x12>\n\x0buser_object\x18\x04\x20\x01(\
    \x0b2\x1b.tensorflow.SavedUserObjectH\0R\nuserObject\x12.\n\x05asset\x18\
    \x05\x20\x01(\x0b2\x16.tensorflow.SavedAssetH\0R\x05asset\x127\n\x08func\
    tion\x18\x06\x20\x01(\x0b2\x19.tensorflow.SavedFunctionH\0R\x08function\
    \x127\n\x08variable\x18\x07\x20\x01(\x0b2\x19.tensorflow.SavedVariableH\
    \0R\x08variable\x12]\n\x16bare_concrete_function\x18\x08\x20\x01(\x0b2%.\
    tensorflow.SavedBareConcreteFunctionH\0R\x14bareConcreteFunction\x127\n\
    \x08constant\x18\t\x20\x01(\x0b2\x19.tensorflow.SavedConstantH\0R\x08con\
    stant\x127\n\x08resource\x18\n\x20\x01(\x0b2\x19.tensorflow.SavedResourc\
    eH\0R\x08resourceB\x06\n\x04kindJ\x04\x08\x02\x10\x03R\nattributes\"\x7f\
    \n\x0fSavedUserObject\x12\x1e\n\nidentifier\x18\x01\x20\x01(\tR\nidentif\
    ier\x120\n\x07version\x18\x02\x20\x01(\x0b2\x16.tensorflow.VersionDefR\
    \x07version\x12\x1a\n\x08metadata\x18\x03\x20\x01(\tR\x08metadata\"=\n\n\
    SavedAsset\x12/\n\x14asset_file_def_index\x18\x01\x20\x01(\x05R\x11asset\
    FileDefIndex\"}\n\rSavedFunction\x12-\n\x12concrete_functions\x18\x01\
    \x20\x03(\tR\x11concreteFunctions\x12=\n\rfunction_spec\x18\x02\x20\x01(\
    \x0b2\x18.tensorflow.FunctionSpecR\x0cfunctionSpec\"\xe3\x01\n\x15SavedC\
    oncreteFunction\x12!\n\x0cbound_inputs\x18\x02\x20\x03(\x05R\x0bboundInp\
    uts\x12_\n\x1dcanonicalized_input_signature\x18\x03\x20\x01(\x0b2\x1b.te\
    nsorflow.StructuredValueR\x1bcanonicalizedInputSignature\x12F\n\x10outpu\
    t_signature\x18\x04\x20\x01(\x0b2\x1b.tensorflow.StructuredValueR\x0fout\
    putSignature\"\xc0\x01\n\x19SavedBareConcreteFunction\x124\n\x16concrete\
    _function_name\x18\x01\x20\x01(\tR\x14concreteFunctionName\x12+\n\x11arg\
    ument_keywords\x18\x02\x20\x03(\tR\x10argumentKeywords\x12@\n\x1callowed\
    _positional_arguments\x18\x03\x20\x01(\x03R\x1aallowedPositionalArgument\
    s\"-\n\rSavedConstant\x12\x1c\n\toperation\x18\x01\x20\x01(\tR\toperatio\
    n\"\xb3\x02\n\rSavedVariable\x12*\n\x05dtype\x18\x01\x20\x01(\x0e2\x14.t\
    ensorflow.DataTypeR\x05dtype\x122\n\x05shape\x18\x02\x20\x01(\x0b2\x1c.t\
    ensorflow.TensorShapeProtoR\x05shape\x12\x1c\n\ttrainable\x18\x03\x20\
    \x01(\x08R\ttrainable\x12M\n\x0fsynchronization\x18\x04\x20\x01(\x0e2#.t\
    ensorflow.VariableSynchronizationR\x0fsynchronization\x12A\n\x0baggregat\
    ion\x18\x05\x20\x01(\x0e2\x1f.tensorflow.VariableAggregationR\x0baggrega\
    tion\x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\"\xbc\x01\n\x0cFuncti\
    onSpec\x12=\n\x0bfullargspec\x18\x01\x20\x01(\x0b2\x1b.tensorflow.Struct\
    uredValueR\x0bfullargspec\x12\x1b\n\tis_method\x18\x02\x20\x01(\x08R\x08\
    isMethod\x12D\n\x0finput_signature\x18\x05\x20\x01(\x0b2\x1b.tensorflow.\
    StructuredValueR\x0einputSignatureJ\x04\x08\x03\x10\x04J\x04\x08\x04\x10\
    \x05\"'\n\rSavedResource\x12\x16\n\x06device\x18\x01\x20\x01(\tR\x06devi\
    ceB\x03\xf8\x01\x01J\x9c2\n\x07\x12\x05\0\0\xa3\x01\x01\n\x08\n\x01\x0c\
    \x12\x03\0\0\x12\n\t\n\x02\x03\0\x12\x03\x02\0?\n\t\n\x02\x03\x01\x12\
    \x03\x03\0/\n\t\n\x02\x03\x02\x12\x03\x04\06\n\t\n\x02\x03\x03\x12\x03\
    \x05\0/\n\t\n\x02\x03\x04\x12\x03\x06\02\n\t\n\x02\x03\x05\x12\x03\x07\0\
    2\n\x08\n\x01\x08\x12\x03\t\0\x1f\n\t\n\x02\x08\x1f\x12\x03\t\0\x1f\n\
    \x08\n\x01\x02\x12\x03\x0b\0\x13\n\xea\x03\n\x02\x04\0\x12\x04\x16\0\x20\
    \x012\xcb\x01\x20A\x20SavedObjectGraph\x20is\x20part\x20of\x20object-bas\
    ed\x20SavedModels\x20in\x20TF\x202.0.\x20It\n\x20describes\x20the\x20dir\
    ected\x20graph\x20of\x20Python\x20objects\x20(or\x20equivalent\x20in\x20\
    other\n\x20languages)\x20that\x20make\x20up\x20a\x20model,\x20with\x20no\
    des[0]\x20at\x20the\x20root.\n2\x8f\x02\x20SavedObjectGraph\x20shares\
    \x20some\x20structure\x20with\x20TrackableObjectGraph,\x20but\n\x20Saved\
    ObjectGraph\x20belongs\x20to\x20the\x20MetaGraph\x20and\x20contains\x20p\
    ointers\x20to\x20functions\n\x20and\x20type\x20information,\x20while\x20\
    TrackableObjectGraph\x20lives\x20in\x20the\x20checkpoint\n\x20and\x20con\
    tains\x20pointers\x20only\x20to\x20variable\x20values.\n\n\n\n\x03\x04\0\
    \x01\x12\x03\x16\x08\x18\n\xa1\x01\n\x04\x04\0\x02\0\x12\x03\x1b\x02!\
    \x1a\x93\x01\x20Flattened\x20list\x20of\x20objects\x20in\x20the\x20objec\
    t\x20graph.\n\n\x20The\x20position\x20of\x20the\x20object\x20in\x20this\
    \x20list\x20indicates\x20its\x20id.\n\x20Nodes[0]\x20is\x20considered\
    \x20the\x20root\x20node.\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x1b\x02\n\
    \n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x1b\x0b\x16\n\x0c\n\x05\x04\0\x02\0\
    \x01\x12\x03\x1b\x17\x1c\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x1b\x1f\x20\
    \n\x95\x01\n\x04\x04\0\x02\x01\x12\x03\x1f\x02<\x1a\x87\x01\x20Informati\
    on\x20about\x20captures\x20and\x20output\x20structures\x20in\x20concrete\
    \x20functions.\n\x20Referenced\x20from\x20SavedBareConcreteFunction\x20a\
    nd\x20SavedFunction.\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x1f\x02$\n\
    \x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x1f%7\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03\x1f:;\n\n\n\x02\x04\x01\x12\x04\"\0?\x01\n\n\n\x03\x04\x01\x01\
    \x12\x03\"\x08\x13\n\x93\x01\n\x04\x04\x01\x02\0\x12\x04'\x02(\x13\x1a\
    \x84\x01\x20Objects\x20which\x20this\x20object\x20depends\x20on:\x20name\
    d\x20edges\x20in\x20the\x20dependency\n\x20graph.\n\n\x20Note:\x20curren\
    tly\x20only\x20valid\x20if\x20kind\x20==\x20\"user_object\".\n\n\x0c\n\
    \x05\x04\x01\x02\0\x04\x12\x03'\x02\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\
    \x03'\x0b?\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03(\x06\x0e\n\x0c\n\x05\
    \x04\x01\x02\0\x03\x12\x03(\x11\x12\nI\n\x03\x04\x01\n\x12\x03+\x02\x18\
    \x1a=\x20Removed\x20when\x20forking\x20SavedObject\x20from\x20TrackableO\
    bjectGraph.\n\n\x0b\n\x04\x04\x01\n\0\x12\x03+\x0b\x17\n\n\n\x03\x04\x01\
    \t\x12\x03,\x02\r\n\x0b\n\x04\x04\x01\t\0\x12\x03,\x0b\x0c\n\x0c\n\x05\
    \x04\x01\t\0\x01\x12\x03,\x0b\x0c\n\x0c\n\x05\x04\x01\t\0\x02\x12\x03,\
    \x0b\x0c\n\xef\x01\n\x04\x04\x01\x02\x01\x12\x043\x024\x19\x1a\xe0\x01\
    \x20Slot\x20variables\x20owned\x20by\x20this\x20object.\x20This\x20descr\
    ibes\x20the\x20three-way\n\x20(optimizer,\x20variable,\x20slot\x20variab\
    le)\x20relationship;\x20none\x20of\x20the\x20three\n\x20depend\x20on\x20\
    the\x20others\x20directly.\n\n\x20Note:\x20currently\x20only\x20valid\
    \x20if\x20kind\x20==\x20\"user_object\".\n\n\x0c\n\x05\x04\x01\x02\x01\
    \x04\x12\x033\x02\n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x033\x0bE\n\x0c\
    \n\x05\x04\x01\x02\x01\x01\x12\x034\x06\x14\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x034\x17\x18\n\x0c\n\x04\x04\x01\x08\0\x12\x046\x02>\x03\n\x0c\
    \n\x05\x04\x01\x08\0\x01\x12\x036\x08\x0c\n\x0b\n\x04\x04\x01\x02\x02\
    \x12\x037\x04$\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x037\x04\x13\n\x0c\n\
    \x05\x04\x01\x02\x02\x01\x12\x037\x14\x1f\n\x0c\n\x05\x04\x01\x02\x02\
    \x03\x12\x037\"#\n\x0b\n\x04\x04\x01\x02\x03\x12\x038\x04\x19\n\x0c\n\
    \x05\x04\x01\x02\x03\x06\x12\x038\x04\x0e\n\x0c\n\x05\x04\x01\x02\x03\
    \x01\x12\x038\x0f\x14\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x038\x17\x18\n\
    \x0b\n\x04\x04\x01\x02\x04\x12\x039\x04\x1f\n\x0c\n\x05\x04\x01\x02\x04\
    \x06\x12\x039\x04\x11\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x039\x12\x1a\n\
    \x0c\n\x05\x04\x01\x02\x04\x03\x12\x039\x1d\x1e\n\x0b\n\x04\x04\x01\x02\
    \x05\x12\x03:\x04\x1f\n\x0c\n\x05\x04\x01\x02\x05\x06\x12\x03:\x04\x11\n\
    \x0c\n\x05\x04\x01\x02\x05\x01\x12\x03:\x12\x1a\n\x0c\n\x05\x04\x01\x02\
    \x05\x03\x12\x03:\x1d\x1e\n\x0b\n\x04\x04\x01\x02\x06\x12\x03;\x049\n\
    \x0c\n\x05\x04\x01\x02\x06\x06\x12\x03;\x04\x1d\n\x0c\n\x05\x04\x01\x02\
    \x06\x01\x12\x03;\x1e4\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03;78\n\x0b\
    \n\x04\x04\x01\x02\x07\x12\x03<\x04\x1f\n\x0c\n\x05\x04\x01\x02\x07\x06\
    \x12\x03<\x04\x11\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03<\x12\x1a\n\x0c\
    \n\x05\x04\x01\x02\x07\x03\x12\x03<\x1d\x1e\n\x0b\n\x04\x04\x01\x02\x08\
    \x12\x03=\x04\x20\n\x0c\n\x05\x04\x01\x02\x08\x06\x12\x03=\x04\x11\n\x0c\
    \n\x05\x04\x01\x02\x08\x01\x12\x03=\x12\x1a\n\x0c\n\x05\x04\x01\x02\x08\
    \x03\x12\x03=\x1d\x1f\n\xc7\x02\n\x02\x04\x02\x12\x04G\0N\x01\x1a\xba\
    \x02\x20A\x20SavedUserObject\x20is\x20an\x20object\x20(in\x20the\x20obje\
    ct-oriented\x20language\x20of\x20the\n\x20TensorFlow\x20program)\x20of\
    \x20some\x20user-\x20or\x20framework-defined\x20class\x20other\x20than\n\
    \x20those\x20handled\x20specifically\x20by\x20the\x20other\x20kinds\x20o\
    f\x20SavedObjects.\n\n\x20This\x20object\x20cannot\x20be\x20evaluated\
    \x20as\x20a\x20tensor,\x20and\x20therefore\x20cannot\x20be\x20bound\n\
    \x20to\x20an\x20input\x20of\x20a\x20function.\n\n\n\n\x03\x04\x02\x01\
    \x12\x03G\x08\x17\nW\n\x04\x04\x02\x02\0\x12\x03I\x02\x18\x1aJ\x20Corres\
    ponds\x20to\x20a\x20registration\x20of\x20the\x20type\x20to\x20use\x20in\
    \x20the\x20loading\x20program.\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03I\
    \x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03I\t\x13\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03I\x16\x17\nM\n\x04\x04\x02\x02\x01\x12\x03K\x02\
    \x19\x1a@\x20Version\x20information\x20from\x20the\x20producer\x20of\x20\
    this\x20SavedUserObject.\n\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x03K\x02\
    \x0c\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03K\r\x14\n\x0c\n\x05\x04\x02\
    \x02\x01\x03\x12\x03K\x17\x18\n/\n\x04\x04\x02\x02\x02\x12\x03M\x02\x16\
    \x1a\"\x20Initialization-related\x20metadata.\n\n\x0c\n\x05\x04\x02\x02\
    \x02\x05\x12\x03M\x02\x08\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03M\t\x11\
    \n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03M\x14\x15\n\x8b\x02\n\x02\x04\
    \x03\x12\x04U\0[\x01\x1a\xfe\x01\x20A\x20SavedAsset\x20points\x20to\x20a\
    n\x20asset\x20in\x20the\x20MetaGraph.\n\n\x20When\x20bound\x20to\x20a\
    \x20function\x20this\x20object\x20evaluates\x20to\x20a\x20tensor\x20with\
    \x20the\x20absolute\n\x20filename.\x20Users\x20should\x20not\x20depend\
    \x20on\x20a\x20particular\x20part\x20of\x20the\x20filename\x20to\n\x20re\
    main\x20stable\x20(e.g.\x20basename\x20could\x20be\x20changed).\n\n\n\n\
    \x03\x04\x03\x01\x12\x03U\x08\x12\n\xca\x01\n\x04\x04\x03\x02\0\x12\x03Z\
    \x02!\x1a\xbc\x01\x20Index\x20into\x20`MetaGraphDef.asset_file_def[]`\
    \x20that\x20describes\x20the\x20Asset.\n\n\x20Only\x20the\x20field\x20`A\
    ssetFileDef.filename`\x20is\x20used.\x20Other\x20fields,\x20such\x20as\n\
    \x20`AssetFileDef.tensor_info`,\x20MUST\x20be\x20ignored.\n\n\x0c\n\x05\
    \x04\x03\x02\0\x05\x12\x03Z\x02\x07\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03Z\x08\x1c\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03Z\x1f\x20\nV\n\x02\
    \x04\x04\x12\x04^\0a\x01\x1aJ\x20A\x20function\x20with\x20multiple\x20si\
    gnatures,\x20possibly\x20with\x20non-Tensor\x20arguments.\n\n\n\n\x03\
    \x04\x04\x01\x12\x03^\x08\x15\n\x0b\n\x04\x04\x04\x02\0\x12\x03_\x02)\n\
    \x0c\n\x05\x04\x04\x02\0\x04\x12\x03_\x02\n\n\x0c\n\x05\x04\x04\x02\0\
    \x05\x12\x03_\x0b\x11\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03_\x12$\n\x0c\
    \n\x05\x04\x04\x02\0\x03\x12\x03_'(\n\x0b\n\x04\x04\x04\x02\x01\x12\x03`\
    \x02!\n\x0c\n\x05\x04\x04\x02\x01\x06\x12\x03`\x02\x0e\n\x0c\n\x05\x04\
    \x04\x02\x01\x01\x12\x03`\x0f\x1c\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\
    \x03`\x1f\x20\n\x8b\x01\n\x02\x04\x05\x12\x04e\0r\x01\x1a\x7f\x20Stores\
    \x20low-level\x20information\x20about\x20a\x20concrete\x20function.\x20R\
    eferenced\x20in\x20either\n\x20a\x20SavedFunction\x20or\x20a\x20SavedBar\
    eConcreteFunction.\n\n\n\n\x03\x04\x05\x01\x12\x03e\x08\x1d\n\xfe\x01\n\
    \x04\x04\x05\x02\0\x12\x03j\x02\"\x1a\xf0\x01\x20Bound\x20inputs\x20to\
    \x20the\x20function.\x20The\x20SavedObjects\x20identified\x20by\x20the\
    \x20node\x20ids\n\x20given\x20here\x20are\x20appended\x20as\x20extra\x20\
    inputs\x20to\x20the\x20caller-supplied\x20inputs.\n\x20The\x20only\x20ty\
    pes\x20of\x20SavedObjects\x20valid\x20here\x20are\x20SavedVariable,\x20S\
    avedResource\n\x20and\x20SavedAsset.\n\n\x0c\n\x05\x04\x05\x02\0\x04\x12\
    \x03j\x02\n\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03j\x0b\x10\n\x0c\n\x05\
    \x04\x05\x02\0\x01\x12\x03j\x11\x1d\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03j\x20!\n_\n\x04\x04\x05\x02\x01\x12\x03m\x024\x1aR\x20Input\x20in\
    \x20canonicalized\x20form\x20that\x20was\x20received\x20to\x20create\x20\
    this\x20concrete\n\x20function.\n\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\
    \x03m\x02\x11\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03m\x12/\n\x0c\n\x05\
    \x04\x05\x02\x01\x03\x12\x03m23\n\xe0\x01\n\x04\x04\x05\x02\x02\x12\x03q\
    \x02'\x1a\xd2\x01\x20Output\x20that\x20was\x20the\x20return\x20value\x20\
    of\x20this\x20function\x20after\x20replacing\x20all\n\x20Tensors\x20with\
    \x20TensorSpecs.\x20This\x20can\x20be\x20an\x20arbitrary\x20nested\x20fu\
    nction\x20and\x20will\n\x20be\x20used\x20to\x20reconstruct\x20the\x20ful\
    l\x20structure\x20from\x20pure\x20tensors.\n\n\x0c\n\x05\x04\x05\x02\x02\
    \x06\x12\x03q\x02\x11\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03q\x12\"\n\
    \x0c\n\x05\x04\x05\x02\x02\x03\x12\x03q%&\n\n\n\x02\x04\x06\x12\x04t\0|\
    \x01\n\n\n\x03\x04\x06\x01\x12\x03t\x08!\n2\n\x04\x04\x06\x02\0\x12\x03v\
    \x02$\x1a%\x20Identifies\x20a\x20SavedConcreteFunction.\n\n\x0c\n\x05\
    \x04\x06\x02\0\x05\x12\x03v\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\
    \x03v\t\x1f\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03v\"#\nE\n\x04\x04\x06\
    \x02\x01\x12\x03y\x02(\x1a8\x20A\x20sequence\x20of\x20unique\x20strings,\
    \x20one\x20per\x20Tensor\x20argument.\n\n\x0c\n\x05\x04\x06\x02\x01\x04\
    \x12\x03y\x02\n\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03y\x0b\x11\n\x0c\n\
    \x05\x04\x06\x02\x01\x01\x12\x03y\x12#\n\x0c\n\x05\x04\x06\x02\x01\x03\
    \x12\x03y&'\nU\n\x04\x04\x06\x02\x02\x12\x03{\x02)\x1aH\x20The\x20prefix\
    \x20of\x20`argument_keywords`\x20which\x20may\x20be\x20identified\x20by\
    \x20position.\n\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03{\x02\x07\n\x0c\n\
    \x05\x04\x06\x02\x02\x01\x12\x03{\x08$\n\x0c\n\x05\x04\x06\x02\x02\x03\
    \x12\x03{'(\n\x0b\n\x02\x04\x07\x12\x05~\0\x81\x01\x01\n\n\n\x03\x04\x07\
    \x01\x12\x03~\x08\x15\nX\n\x04\x04\x07\x02\0\x12\x04\x80\x01\x02\x17\x1a\
    J\x20An\x20Operation\x20name\x20for\x20a\x20ConstantOp\x20in\x20this\x20\
    SavedObjectGraph's\x20MetaGraph.\n\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\
    \x80\x01\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x80\x01\t\x12\n\r\n\
    \x05\x04\x07\x02\0\x03\x12\x04\x80\x01\x15\x16\ng\n\x02\x04\x08\x12\x06\
    \x85\x01\0\x8c\x01\x01\x1aY\x20Represents\x20a\x20Variable\x20that\x20is\
    \x20initialized\x20by\x20loading\x20the\x20contents\x20from\x20the\n\x20\
    checkpoint.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x85\x01\x08\x15\n\x0c\n\
    \x04\x04\x08\x02\0\x12\x04\x86\x01\x02\x15\n\r\n\x05\x04\x08\x02\0\x06\
    \x12\x04\x86\x01\x02\n\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x86\x01\x0b\
    \x10\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x86\x01\x13\x14\n\x0c\n\x04\x04\
    \x08\x02\x01\x12\x04\x87\x01\x02\x1d\n\r\n\x05\x04\x08\x02\x01\x06\x12\
    \x04\x87\x01\x02\x12\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\x87\x01\x13\
    \x18\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\x87\x01\x1b\x1c\n\x0c\n\x04\
    \x04\x08\x02\x02\x12\x04\x88\x01\x02\x15\n\r\n\x05\x04\x08\x02\x02\x05\
    \x12\x04\x88\x01\x02\x06\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\x88\x01\
    \x07\x10\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\x88\x01\x13\x14\n\x0c\n\
    \x04\x04\x08\x02\x03\x12\x04\x89\x01\x02.\n\r\n\x05\x04\x08\x02\x03\x06\
    \x12\x04\x89\x01\x02\x19\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\x89\x01\
    \x1a)\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\x89\x01,-\n\x0c\n\x04\x04\
    \x08\x02\x04\x12\x04\x8a\x01\x02&\n\r\n\x05\x04\x08\x02\x04\x06\x12\x04\
    \x8a\x01\x02\x15\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\x8a\x01\x16!\n\r\
    \n\x05\x04\x08\x02\x04\x03\x12\x04\x8a\x01$%\n\x0c\n\x04\x04\x08\x02\x05\
    \x12\x04\x8b\x01\x02\x12\n\r\n\x05\x04\x08\x02\x05\x05\x12\x04\x8b\x01\
    \x02\x08\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\x8b\x01\t\r\n\r\n\x05\x04\
    \x08\x02\x05\x03\x12\x04\x8b\x01\x10\x11\n\x8b\x01\n\x02\x04\t\x12\x06\
    \x90\x01\0\x99\x01\x01\x1a}\x20Represents\x20`FunctionSpec`\x20used\x20i\
    n\x20`Function`.\x20This\x20represents\x20a\n\x20function\x20that\x20has\
    \x20been\x20wrapped\x20as\x20a\x20TensorFlow\x20`Function`.\n\n\x0b\n\
    \x03\x04\t\x01\x12\x04\x90\x01\x08\x14\n<\n\x04\x04\t\x02\0\x12\x04\x92\
    \x01\x02\"\x1a.\x20Full\x20arg\x20spec\x20from\x20inspect.getfullargspec\
    ().\n\n\r\n\x05\x04\t\x02\0\x06\x12\x04\x92\x01\x02\x11\n\r\n\x05\x04\t\
    \x02\0\x01\x12\x04\x92\x01\x12\x1d\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x92\
    \x01\x20!\n7\n\x04\x04\t\x02\x01\x12\x04\x94\x01\x02\x15\x1a)\x20Whether\
    \x20this\x20represents\x20a\x20class\x20method.\n\n\r\n\x05\x04\t\x02\
    \x01\x05\x12\x04\x94\x01\x02\x06\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x94\
    \x01\x07\x10\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x94\x01\x13\x14\n2\n\
    \x04\x04\t\x02\x02\x12\x04\x96\x01\x02&\x1a$\x20The\x20input\x20signatur\
    e,\x20if\x20specified.\n\n\r\n\x05\x04\t\x02\x02\x06\x12\x04\x96\x01\x02\
    \x11\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\x96\x01\x12!\n\r\n\x05\x04\t\
    \x02\x02\x03\x12\x04\x96\x01$%\n\x0b\n\x03\x04\t\t\x12\x04\x98\x01\x02\
    \x10\n\x0c\n\x04\x04\t\t\0\x12\x04\x98\x01\x0b\x0c\n\r\n\x05\x04\t\t\0\
    \x01\x12\x04\x98\x01\x0b\x0c\n\r\n\x05\x04\t\t\0\x02\x12\x04\x98\x01\x0b\
    \x0c\n\x0c\n\x04\x04\t\t\x01\x12\x04\x98\x01\x0e\x0f\n\r\n\x05\x04\t\t\
    \x01\x01\x12\x04\x98\x01\x0e\x0f\n\r\n\x05\x04\t\t\x01\x02\x12\x04\x98\
    \x01\x0e\x0f\n\xc1\x01\n\x02\x04\n\x12\x06\x9e\x01\0\xa3\x01\x01\x1a\xb2\
    \x01\x20A\x20SavedResource\x20represents\x20a\x20TF\x20object\x20that\
    \x20holds\x20state\x20during\x20its\x20lifetime.\n\x20An\x20object\x20of\
    \x20this\x20type\x20can\x20have\x20a\x20reference\x20to\x20a:\n\x20creat\
    e_resource()\x20and\x20an\x20initialize()\x20function.\n\n\x0b\n\x03\x04\
    \n\x01\x12\x04\x9e\x01\x08\x15\n\xad\x01\n\x04\x04\n\x02\0\x12\x04\xa2\
    \x01\x02\x14\x1a\x9e\x01\x20A\x20device\x20specification\x20indicating\
    \x20a\x20required\x20placement\x20for\x20the\x20resource\n\x20creation\
    \x20function,\x20e.g.\x20\"CPU\".\x20An\x20empty\x20string\x20allows\x20\
    the\x20user\x20to\x20select\x20a\n\x20device.\n\n\r\n\x05\x04\n\x02\0\
    \x05\x12\x04\xa2\x01\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xa2\x01\t\
    \x0f\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xa2\x01\x12\x13b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
